<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/06/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>如何讓不同的子類別同步父類別屬性值</title>
    <url>/2024/06/03/CSharp/csharp-copy-properties-the-same-base-class/</url>
    <content><![CDATA[<p>在開發程式時，習慣為 data model 建立個 base class 方便把常用的 properties 包裝起來，或是做一些客製的處理。隨著繼續的子類別變多時，有遇過幾次 <code>需要將某個子類別 copy 屬性至不同子類別</code>。<br>按照物件導向原理∶ <strong>子類別無法互轉，或是先轉父類別再轉子類別</strong>。如果要做到複雜屬性的目的，只能經過 Relction 的方式了，以下將介紹如何使用。</p>
<span id="more"></span>

<h1 id="作法說明"><a href="#作法說明" class="headerlink" title="作法說明"></a>作法說明</h1><ol>
<li>確認二個子類別均繼承相同的父類別</li>
<li>建立一個 Extension 並且定義使用的物件必須是父類別家族的人</li>
<li>利用 Reflection 的方式將 Properties 取出 (由於二者均是相同的父類別，所以該有的屬性均會存在)</li>
<li>範例程式</li>
</ol>
<ul>
<li>先定義範例用的父類別&#x2F;子類別  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace TodoApi.Models</span><br><span class="line">&#123;</span><br><span class="line">    public abstract class BaseInfo</span><br><span class="line">    &#123;</span><br><span class="line">        public string UserName &#123; get; set; &#125;  </span><br><span class="line">        public string Old &#123; get; set; &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    public class Student : BaseInfo</span><br><span class="line">    &#123;</span><br><span class="line">        public string School &#123; get; set; &#125;  </span><br><span class="line">        public string Dept &#123; get; set; &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    public class Employee : BaseInfo</span><br><span class="line">    &#123;</span><br><span class="line">        public string Company &#123; get; set; &#125;</span><br><span class="line">        public string Salary &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Extension 寫法  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static class ObjectExtensions</span><br><span class="line">&#123;</span><br><span class="line">    public static void CopyProperiesFromBaseClass&lt;T, Y&gt;(this T self, Y from)</span><br><span class="line">    where T : BaseInfo</span><br><span class="line">    where Y : BaseInfo</span><br><span class="line">    &#123;</span><br><span class="line">        var selfProperties = self.GetType().GetProperties();</span><br><span class="line">        var fromProperties = from.GetType().GetProperties();</span><br><span class="line">        foreach (var item in fromProperties)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine($&quot;feed proprerty &#123;item.Name&#125;=&#123;item.GetValue(from)&#125;&quot;);</span><br><span class="line">            selfProperties.Where(x =&gt; x.Name == item.Name).FirstOrDefault()?.SetValue(self, item.GetValue(from));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用法(以 ASP.NET 為例)  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[HttpPost]</span><br><span class="line"> public Employee ConvertData(Student student) &#123;</span><br><span class="line">     var sBaseInfo = student as BaseInfo;</span><br><span class="line">     var employee = new Employee();   </span><br><span class="line">     employee.CopyProperiesFromBaseClass(sBaseInfo);   </span><br><span class="line">     return employee;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://www.pluralsight.com/resources/blog/guides/property-copying-between-two-objects-using-reflection">Property Copying Between Two Objects using Reflection</a></li>
</ul>
]]></content>
      <tags>
        <tag>C#</tag>
        <tag>.NET</tag>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>程式化發送 GitHub 的 PullRequest，解決手動 winget 上架</title>
    <url>/2020/06/20/DevOps/auto-deploy-winget-by-github/</url>
    <content><![CDATA[<p>人都是想偷懶的，本篇介紹怎麼程式化發 Pull Reqeust，解決手動上新的版本到 <a href="https://docs.microsoft.com/zh-tw/windows/package-manager/winget/">winget</a> 的流程。</p>
<span id="more"></span>

<p>微軟 <a href="https://www.zdnet.com/article/microsofts-windows-package-manager-this-command-line-tool-can-install-all-your-apps/">&#x2F;&#x2F;build 2020</a> 推出 <a href="https://docs.microsoft.com/zh-tw/windows/package-manager/winget/">winget</a> 可讓開發人員在 Windows 10 電腦上探索、安裝、升級、移除和設定應用程式。</p>
<p>讓我想要把自己的程式也放到 winget 上，讓其他人也可以直接下載。</p>
<p>要怎麼送程式到 <a href="https://docs.microsoft.com/zh-tw/windows/package-manager/winget/">winget</a> 呢？</p>
<p>根據 Submit packages to Windows Packages Manager 介紹，目前 <a href="https://docs.microsoft.com/zh-tw/windows/package-manager/winget/">winget</a> 沒有上架的工具，要上程式到 <a href="https://docs.microsoft.com/zh-tw/windows/package-manager/winget/">winget</a> 有兩個步驟：</p>
<p>建立一份 manifest，提供程式的說明(作者, 授權, 下載 URL, checksum, … 等)<br>藉由 GitHub 來發 Pull Reqeust 到 winget-pkgs repo</p>
<h1 id="Create-your-package-manifest"><a href="#Create-your-package-manifest" class="headerlink" title="Create your package manifest"></a>Create your package manifest</h1><p>manifest 是一份 YAML 描述程式的基本資訊，基本必要資訊如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id: string # Publisher.package format. （必須是唯一的）</span><br><span class="line">Publisher: string # The name of the publisher.</span><br><span class="line">Name: string # The name of the application.</span><br><span class="line">Version: string # Version numbering format.</span><br><span class="line">License: string # The open source license or copyright.</span><br><span class="line">InstallerType: string # Enumeration of supported installer types (exe, msi, msix, inno, wix, nullsoft, appx).</span><br><span class="line">Installers:</span><br><span class="line">  - Arch: string # Enumeration of supported architectures.</span><br><span class="line">  - Url: string # Path to download installation file.</span><br><span class="line">  - Sha256: string # SHA256 calculated from installer.</span><br><span class="line">ManifestVersion: 0.1.0</span><br></pre></td></tr></table></figure>
<p>範例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id: microsoft.teams</span><br><span class="line">Publisher: Microsoft Corporation</span><br><span class="line">Name: Microsoft Teams</span><br><span class="line">Version: 1.3.0.4461</span><br><span class="line">License: Copyright (c) Microsoft Corporation. All rights reserved.</span><br><span class="line">InstallerType: exe</span><br><span class="line">Installers:</span><br><span class="line">  - Arch: x64</span><br><span class="line">    Url: https://statics.teams.cdn.office.net/production-windows-x64/1.3.00.4461/Teams_windows_x64.exe</span><br><span class="line">    Sha256: 712f139d71e56bfb306e4a7b739b0e1109abb662dfa164192a5cfd6adb24a4e1</span><br><span class="line">ManifestVersion: 0.1.0</span><br></pre></td></tr></table></figure>
<p>介紹幾個比較特別的參數：</p>
<ul>
<li>Silent：可以強迫在安裝過程沒有出現任何需要人為操作的畫面，在 winget 安裝非常適合</li>
<li>SilentWithProgress：功能類似 Silent</li>
<li>Commands：可搭配在安裝時執行特定的指令</li>
</ul>
<p>更多詳細的 schema 可以參考：<a href="https://docs.microsoft.com/en-us/windows/package-manager/package/manifest?tabs=minexample,compschema#complete-schema">Complete Shcema</a>。</p>
<p>了解 manifest 的格式之後，下面介紹怎麼建立 manifest：</p>
<ol>
<li>登入 GitHub 帳號</li>
<li>fork <a href="https://github.com/microsoft/winget-pkgs">winget-pkgs</a> repo 到自己的帳號下</li>
<li>clone 自己帳號下的 <a href="https://github.com/microsoft/winget-pkgs">winget-pkgs</a> repo 到本機</li>
<li>進入 clone 下來的 manifest 目錄，建立專屬的 {publisher} 目錄，例如：我是 pou lin。如果未來同一個 {publisher} 發多個 apps 都只能放1. 在這個 {publisher} 目錄</li>
<li>在 {publisher} 目錄下，建立 {app} 目錄，例如：我的程式叫 just love radio，目錄名稱就是 just love radio。</li>
<li>在 {app} 目錄下，建立 {version}.yaml。{version}.yaml 每個不同版本都會有一份，例如：1.0.0.0.yaml，1.0.2.0.yaml<ul>
<li>產生 yaml 檔案，可以 Tool 目錄中找到 YamlCreate.ps1，利用 Powershell 執行它來加以建立 yaml</li>
<li>目錄結構如圖範例：<br><img src="/2020/06/20/DevOps/auto-deploy-winget-by-github/1592638339.png"></li>
</ul>
</li>
<li>準備好 {version}.yaml 可以發 git push 到自己的 repo</li>
<li>最後在自己的 winget-pkgs repo 發一個 PullRequest 到 microsoft&#x2F;winget-pkgs 就完成了</li>
</ol>
<p>建立 manifest 需要注意的地方，可以參考：<a href="https://docs.microsoft.com/en-us/windows/package-manager/package/manifest?tabs=minexample,compschema#tips-and-best-practices">Tips and best practices</a>。</p>
<h1 id="Custom-Powershell-script-to-auto-create-YAML-and-send-Pull-Request-to-GitHub"><a href="#Custom-Powershell-script-to-auto-create-YAML-and-send-Pull-Request-to-GitHub" class="headerlink" title="Custom Powershell script to auto create YAML and send Pull Request to GitHub"></a>Custom Powershell script to auto create YAML and send Pull Request to GitHub</h1><p>上面介紹是手動處理方式，雖然步驟不多，但每次有新版本發布都要再做一次。<br>我很懶惰，身為開發人員能減少這種手動的流程是最基本的。<br>分析 {manifest}.yaml 的基本參數跟學習 GitHub 的 GraphQL API 後，<br>我寫出了 Powershell 的 script 來自動化幫我完成手動的流程。</p>
<p>要自動化處理這些流程有幾個重要的組成元素：</p>
<h2 id="準備可以檢查是否有新版的地方"><a href="#準備可以檢查是否有新版的地方" class="headerlink" title="準備可以檢查是否有新版的地方"></a>準備可以檢查是否有新版的地方</h2><p>不管是用 Jenkins 或其他 CI，建議準備一個地方紀錄目前最新版本的資訊，讓 script 可以檢查是否有新的版本要發給 winget。<br>例如：我準備一個 json 檔案，再每次 Jenkins 建立新版本時，自動更新該份 json 留下最新的版本資訊。<br>內文如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;packages&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">       &quot;version&quot; : &quot;10.0.2&quot;,</span><br><span class="line">       &quot;code&quot; : 100002,</span><br><span class="line">       &quot;url&quot; : &quot;https://poumason.internal.com/jlr/100002.msi&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自動檢查更新並產生-version-yaml-的內容"><a href="#自動檢查更新並產生-version-yaml-的內容" class="headerlink" title="自動檢查更新並產生 {version}.yaml 的內容"></a>自動檢查更新並產生 {version}.yaml 的內容</h2><p>根據 <a href="https://docs.microsoft.com/en-us/windows/package-manager/package/manifest?tabs=minexample,compschema#minimal-required-schema">Minimal required schema</a> 定義，準備需要的參數，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Write-Host &quot;1. 從 https://poumason.internal.com/jlr/version.json 檢查是否有新版本&quot;</span><br><span class="line"></span><br><span class="line">$response = Invoke-WebRequest -Uri &quot;https://poumason.internal.com/jlr/version.json&quot;</span><br><span class="line">$jsonObj = ConvertFrom-Json $([String]::new($response.Content))</span><br><span class="line">$lastestVer = $jsonObj.versions[0].version</span><br><span class="line">$lastestUrl = $jsonObj.supports[0].url</span><br><span class="line">$previousVer = $lastestVer</span><br><span class="line"></span><br><span class="line"># 讀取本機的暫存檔，檢查上次抓到的版本跟最新的版本是否一致</span><br><span class="line">$cacheFile = &quot;..\.\winget_ver.txt&quot;</span><br><span class="line">if(![System.IO.File]::Exists($cacheFile))&#123; SET-Content -Path $cacheFile -Value $lastestVer &#125; else &#123; $previousVer = Get-Content -Path $cacheFile &#125;</span><br><span class="line">if ($previousVer -eq $lastestVer) &#123; </span><br><span class="line">   Write-Host &quot;*** The same version ***&quot; -ForeGroundColor Blue </span><br><span class="line">&#125; else &#123;</span><br><span class="line">  # 準備一個新的 branch</span><br><span class="line">  $branchName = &quot;jlr-$&#123;lastestVer&#125;&quot;</span><br><span class="line">  git branch -D $branchName</span><br><span class="line">  git branch $branchName</span><br><span class="line">  git checkout $branchName</span><br><span class="line">  # 準備一個存安裝檔</span><br><span class="line">  $exeFile  = &quot;.\jlr-$&#123;lastestVer&#125;.msi&quot;;</span><br><span class="line"></span><br><span class="line">  Write-Host &quot;2. 下載 url 中的檔案 $&#123;exeFile&#125;&quot;</span><br><span class="line">  Invoke-WebRequest $lastestUrl -OutFile $exeFile</span><br><span class="line"></span><br><span class="line">  Write-Host &quot;3. 取得下載好檔案的 checksum $&#123;exeFile&#125;&quot;</span><br><span class="line">  $checkSum = (Get-FileHash $exeFile -Algorithm sha256).hash</span><br><span class="line">  rm $exeFile</span><br><span class="line"></span><br><span class="line">  Write-Host &quot;4. 產生新版本的 $&#123;lastestVer&#125;.yaml&quot;</span><br><span class="line">  # publisherFolder 可根據自己的名稱與 App 名稱做改變</span><br><span class="line">  $publisherFolder = &quot;poulin\jlr&quot;</span><br><span class="line">  $fileName = &quot;.\manifests\$&#123;publisherFolder&#125;\$&#123;lastestVer&#125;.yaml&quot;</span><br><span class="line">  # 寫入 ID</span><br><span class="line">  $string = &quot;Id: poulin.jlr&quot;</span><br><span class="line">  write-output $string | out-file $filename</span><br><span class="line">  # 寫入 Version</span><br><span class="line">  $string = &quot;Version: &quot; + $lastestVer</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line">  # 寫入 App 名稱</span><br><span class="line">  $string = &quot;Name: Just Love Radio&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line">  # 寫入 Publisher </span><br><span class="line">  $string = &quot;Publisher: Pou Lin&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line">  # 寫入 License </span><br><span class="line">  $string = &quot;License: Copyright (c) Pou Lin All Rights Reserved.&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line">  # 寫入 InstallerType</span><br><span class="line">  $string = &quot;InstallerType: msi&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;Installers:&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;  - Arch: x86&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;    Url: &quot; + $lastestUrl</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;    Sha256: &quot; + $checkSum</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line">  # 加入 Silent 與 SilentWithProgress</span><br><span class="line">  $string = &quot;    Switches:&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;      Silent: /S&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;      SilentWithProgress: /S&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  Write-Host &quot;5. 更新暫存檔案到最新檢查的版本 $&#123;cacheFile&#125;&quot;</span><br><span class="line">  SET-Content -Path $cacheFile -Value $lastestVer </span><br><span class="line">  Write-host GET-Content -Path $cacheFile</span><br><span class="line"></span><br><span class="line">  Write-Host &quot;6. 寫入 git commit 並送到自己的 winget-pkgs repo&quot;</span><br><span class="line">  git add $fileName</span><br><span class="line">  $comment = &quot;Add JLR new version $&#123;lastestVer&#125;&quot;</span><br><span class="line">  git commit -m $comment</span><br><span class="line"></span><br><span class="line">  git push --set-upstream origin $branchName</span><br><span class="line">  git push</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>這個 script 需要被放在自己 GitHub 帳號下 clone 到本機的 winget-pkgs 根目錄</strong>中，如下圖：<br><img src="/2020/06/20/DevOps/auto-deploy-winget-by-github/1592646366.png"><br>因為裡面會產生新的 {version}.yaml，它需要被 push 到自己的 repo 中，才能發 pull request 給 microsoft:winget-pkgs repo。</p>
<h2 id="利用-GraphQL-API-從自己的-winget-pkgs-repo-發-Pull-Request-給-microsof-winget-pkgs-repo"><a href="#利用-GraphQL-API-從自己的-winget-pkgs-repo-發-Pull-Request-給-microsof-winget-pkgs-repo" class="headerlink" title="利用 GraphQL API 從自己的 winget-pkgs repo 發 Pull Request 給 microsof:winget-pkgs repo"></a>利用 GraphQL API 從自己的 winget-pkgs repo 發 Pull Request 給 microsof:winget-pkgs repo</h2><p>要程式化發送 Pull Request 需要使用 <a href="https://developer.github.com/v4/mutation/createpullrequest/">createPullRequest - GraphQL API v4</a>，根據 API 參數說明，我們需要：</p>
<ul>
<li><a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line">Github Personal access token</a><ul>
<li>點擊連結申請 Access Token</li>
</ul>
</li>
<li>microsoft:winget-pkgs repo 的 repo ID<ul>
<li>利用 <a href="https://developer.github.com/v4/explorer/">GraphQL API Explorer</a> 輸入下面的指令得到  repo ID  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    repository(owner: &quot;microsoft&quot;, name: &quot;winget-pkgs&quot;) &#123;</span><br><span class="line">      id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
最後準備如下的程式碼：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Write-Host &quot;7. create pull request for GitHub&quot;</span><br><span class="line">$graphql = &quot;https://api.github.com/graphql&quot;</span><br><span class="line">$accessToken = &quot;&#123;申請自己專用的 GitHub Access Token&#125;&quot;</span><br><span class="line"># microsoft:winget-pkgs 的 repo id</span><br><span class="line">$repoId = &quot;&#123;&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 準備發送 api 的 http request headers</span><br><span class="line">$headers = New-Object &quot;System.Collections.Generic.Dictionary[[String],[String]]&quot;</span><br><span class="line">$headers.Add(&quot;User-Agent&quot;, &#x27;Agent&#x27;)</span><br><span class="line">$headers.Add(&quot;Authorization&quot;, &#x27;bearer &#x27; + $accessToken)</span><br><span class="line"> </span><br><span class="line"># 把 $branchName 加入來源</span><br><span class="line">$branchName = &quot;&#123;你的 github 帳號&#125;:$&#123;branchName&#125;&quot;</span><br><span class="line">$body = &#x27;&#123; &quot;query&quot;: &quot;mutation &#123; createPullRequest(input: &#123; baseRefName: \&quot;master\&quot;, headRefName: \&quot;&#x27; + $branchName + &#x27;\&quot;, repositoryId: \&quot;&#x27; + $repoId + &#x27;\&quot;, title: \&quot;&#x27; + $comment + &#x27;\&quot; , body: \&quot;\&quot;&#125;) &#123; clientMutationId&#125; &#125;&quot;  &#125;&#x27;</span><br><span class="line">echo $body</span><br><span class="line">$response = Invoke-WebRequest -Uri $graphql -Headers $headers -Method &#x27;POST&#x27; -Body $body </span><br><span class="line">echo $response</span><br><span class="line">  </span><br><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
執行的效果如同 <a href="https://github.com/microsoft/winget-pkgs/pull/1940">https://github.com/microsoft/winget-pkgs/pull/1940</a> 我發送的結果。</li>
</ul>
</li>
</ul>
<h2 id="重新整理整份的-script："><a href="#重新整理整份的-script：" class="headerlink" title="重新整理整份的 script："></a>重新整理整份的 script：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Write-Host &quot;1. 從 https://poumason.internal.com/jlr/version.json 檢查是否有新版本&quot;</span><br><span class="line"></span><br><span class="line">$response = Invoke-WebRequest -Uri &quot;https://poumason.internal.com/jlr/version.json&quot;</span><br><span class="line">$jsonObj = ConvertFrom-Json $([String]::new($response.Content))</span><br><span class="line">$lastestVer = $jsonObj.versions[0].version</span><br><span class="line">$lastestUrl = $jsonObj.supports[0].url</span><br><span class="line">$previousVer = $lastestVer</span><br><span class="line"></span><br><span class="line"># 讀取本機的暫存檔，檢查上次抓到的版本跟最新的版本是否一致</span><br><span class="line">$cacheFile = &quot;..\.\winget_ver.txt&quot;</span><br><span class="line">if(![System.IO.File]::Exists($cacheFile))&#123; SET-Content -Path $cacheFile -Value $lastestVer &#125; else &#123; $previousVer = Get-Content -Path $cacheFile &#125;</span><br><span class="line">if ($previousVer -eq $lastestVer) &#123; </span><br><span class="line">   Write-Host &quot;*** The same version ***&quot; -ForeGroundColor Blue </span><br><span class="line">&#125; else &#123;</span><br><span class="line">  # 準備一個新的 branch</span><br><span class="line">  $branchName = &quot;jlr-$&#123;lastestVer&#125;&quot;</span><br><span class="line">  git branch -D $branchName</span><br><span class="line">  git branch $branchName</span><br><span class="line">  git checkout $branchName</span><br><span class="line">  # 準備一個存安裝檔</span><br><span class="line">  $exeFile  = &quot;.\jlr-$&#123;lastestVer&#125;.msi&quot;;</span><br><span class="line"></span><br><span class="line">  Write-Host &quot;2. 下載 url 中的檔案 $&#123;exeFile&#125;&quot;</span><br><span class="line">  Invoke-WebRequest $lastestUrl -OutFile $exeFile</span><br><span class="line"></span><br><span class="line">  Write-Host &quot;3. 取得下載好檔案的 checksum $&#123;exeFile&#125;&quot;</span><br><span class="line">  $checkSum = (Get-FileHash $exeFile -Algorithm sha256).hash</span><br><span class="line">  rm $exeFile</span><br><span class="line"></span><br><span class="line">  Write-Host &quot;4. 產生新版本的 $&#123;lastestVer&#125;.yaml&quot;</span><br><span class="line">  # publisherFolder 可根據自己的名稱與 App 名稱做改變</span><br><span class="line">  $publisherFolder = &quot;poulin\jlr&quot;</span><br><span class="line">  $fileName = &quot;.\manifests\$&#123;publisherFolder&#125;\$&#123;lastestVer&#125;.yaml&quot;</span><br><span class="line">  # 寫入 ID</span><br><span class="line">  $string = &quot;Id: poulin.jlr&quot;</span><br><span class="line">  write-output $string | out-file $filename</span><br><span class="line">  # 寫入 Version</span><br><span class="line">  $string = &quot;Version: &quot; + $lastestVer</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line">  # 寫入 App 名稱</span><br><span class="line">  $string = &quot;Name: Just Love Radio&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line">  # 寫入 Publisher </span><br><span class="line">  $string = &quot;Publisher: Pou Lin&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line">  # 寫入 License </span><br><span class="line">  $string = &quot;License: Copyright (c) Pou Lin All Rights Reserved.&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line">  # 寫入 InstallerType</span><br><span class="line">  $string = &quot;InstallerType: msi&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;Installers:&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;  - Arch: x86&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;    Url: &quot; + $lastestUrl</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;    Sha256: &quot; + $checkSum</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line">  # 加入 Silent 與 SilentWithProgress</span><br><span class="line">  $string = &quot;    Switches:&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;      Silent: /S&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  $string = &quot;      SilentWithProgress: /S&quot;</span><br><span class="line">  write-output $string | out-file $filename -append</span><br><span class="line"></span><br><span class="line">  Write-Host &quot;5. 更新暫存檔案到最新檢查的版本 $&#123;cacheFile&#125;&quot;</span><br><span class="line">  SET-Content -Path $cacheFile -Value $lastestVer </span><br><span class="line">  Write-host GET-Content -Path $cacheFile</span><br><span class="line"></span><br><span class="line">  Write-Host &quot;6. 寫入 git commit 並送到自己的 winget-pkgs repo&quot;</span><br><span class="line">  git add $fileName</span><br><span class="line">  $comment = &quot;Add JLR new version $&#123;lastestVer&#125;&quot;</span><br><span class="line">  git commit -m $comment</span><br><span class="line"></span><br><span class="line">  git push --set-upstream origin $branchName</span><br><span class="line">  git push</span><br><span class="line">  </span><br><span class="line">  Write-Host &quot;7. create pull request for GitHub&quot;</span><br><span class="line">  $graphql = &quot;https://api.github.com/graphql&quot;</span><br><span class="line">  $accessToken = &quot;&#123;申請自己專用的 GitHub Access Token&#125;&quot;</span><br><span class="line">  # microsoft:winget-pkgs 的 repo id</span><br><span class="line">  $repoId = &quot;&#123;&#125;&quot;</span><br><span class="line"></span><br><span class="line">  # 準備發送 api 的 http request headers</span><br><span class="line">  $headers = New-Object &quot;System.Collections.Generic.Dictionary[[String],[String]]&quot;</span><br><span class="line">  $headers.Add(&quot;User-Agent&quot;, &#x27;Agent&#x27;)</span><br><span class="line">  $headers.Add(&quot;Authorization&quot;, &#x27;bearer &#x27; + $accessToken)</span><br><span class="line"> </span><br><span class="line">  # 把 $branchName 加入來源</span><br><span class="line">  $branchName = &quot;&#123;你的 github 帳號&#125;:$&#123;branchName&#125;&quot;</span><br><span class="line">  $body = &#x27;&#123; &quot;query&quot;: &quot;mutation &#123; createPullRequest(input: &#123; baseRefName: \&quot;master\&quot;, headRefName: \&quot;&#x27; + $branchName + &#x27;\&quot;, repositoryId: \&quot;&#x27; + $repoId + &#x27;\&quot;, title: \&quot;&#x27; + $comment + &#x27;\&quot; , body: \&quot;\&quot;&#125;) &#123; clientMutationId&#125; &#125;&quot;  &#125;&#x27;</span><br><span class="line">  echo $body</span><br><span class="line">  $response = Invoke-WebRequest -Uri $graphql -Headers $headers -Method &#x27;POST&#x27; -Body $body </span><br><span class="line">  echo $response</span><br><span class="line">   </span><br><span class="line">  git checkout master</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>再次強調這個 script 要放在跟自己 winget-pkgs 的目錄下，這樣才能正常執行。</p>
<p>在研究 <a href="https://developer.github.com/v4/">GraphQL API</a> 跟 Powershell 指令花了不少時間，感謝 Joe Wen 的幫忙讓我加快不少。<br>上面的 script 歡迎大家使用，如果有任何的 script 的問題歡迎跟我說，希望有幫忙到大家，謝謝。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://developer.github.com/v4/mutation/createpullrequest/">createPullRequest - GraphQL API v4</a></li>
<li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-webrequest?view=powershell-7">Invoke-WebRequest</a></li>
<li><a href="https://davidhamann.de/2019/04/12/powershell-invoke-webrequest-by-example/">HTTP requests with PowerShell’s Invoke-WebRequest – by Example</a></li>
<li><a href="https://jonlabelle.com/snippets/view/powershell/send-a-json-http-api-request-in-powershell">Send a JSON HTTP API Request in PowerShell</a></li>
<li><a href="https://www.systemcenterautomation.com/2019/05/building-json-payload-in-powershell/">Building JSON Payload in Powershell</a></li>
<li><a href="https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line">Creating a personal access token for the command line</a></li>
<li><a href="https://stackoverflow.com/questions/12936150/is-it-possible-to-send-additional-http-headers-to-web-services-via-new-webservic">Is it possible to send additional HTTP headers to web services via New-WebServiceProxy</a></li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Azure functions 使用自定義的 Docker Image</title>
    <url>/2022/01/28/DevOps/custom-image-on-azure-functions/</url>
    <content><![CDATA[<p>如需在 Azure functions 使用特定的 Lib 版本或第三方套件，例如：ffmpeg，可建立專用的 Docker Image。本篇利用 <a href="https://docs.microsoft.com/en-us/azure/developer/javascript/how-to/develop-serverless-apps">Node.js</a> 為例分享使用的心得。</p>
<span id="more"></span>

<h1 id="基本需求"><a href="#基本需求" class="headerlink" title="基本需求"></a>基本需求</h1><ul>
<li>使用 <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-premium-plan">Premium plan</a> 或是 <a href="https://docs.microsoft.com/en-us/azure/azure-functions/dedicated-plan">Dedicated (App Service) plan</a></li>
<li>使用的 docker image 必須基於 <a href="https://hub.docker.com/_/microsoft-azure-functions-base">Azure Functions Base</a></li>
<li>擁有 <a href="https://hub.docker.com/">docker hub</a> 或 <a href="https://azure.microsoft.com/zh-tw/services/container-registry/">Azure Container registry</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-function-linux-custom-image?tabs=in-process,bash,azure-cli&pivots=programming-language-javascript#configure-your-local-environment">開發環境安裝必要的工具</a></li>
</ul>
<p>下面分別介紹幾個步驟</p>
<h1 id="建立-Docker-Image-加入需要的內容"><a href="#建立-Docker-Image-加入需要的內容" class="headerlink" title="建立 Docker Image 加入需要的內容"></a>建立 Docker Image 加入需要的內容</h1><blockquote>
<p>沒有 Azure functions 專案，參考 建立和測試本機 Functions 專案 準備具有 Http Trigger專案；<br>在本機專案的根目錄建立 Dockerfile，並填入 ffmpeg 與 curl 的安裝。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM mcr.microsoft.com/azure-functions/node:3.0</span><br><span class="line"># Install ffmpeg and curl</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get -y install curl</span><br><span class="line">RUN apt-get -y install ffmpeg</span><br><span class="line"># Setting environment variables of Azure functions</span><br><span class="line">ENV AzureWebJobsScriptRoot=/home/site/wwwroot \</span><br><span class="line">    AzureFunctionsJobHost__Logging__Console__IsEnabled=true</span><br><span class="line">COPY . /home/site/wwwroot</span><br><span class="line">RUN cd /home/site/wwwroot &amp;&amp; \</span><br><span class="line">    npm install</span><br></pre></td></tr></table></figure>
<p>上述指令把專案中所有的 functions 複製到 <strong>&#x2F;home&#x2F;site&#x2F;wwwroot</strong>。專案目錄結構需要符合基本規範。</p>
<p>介紹環境變數：</p>
<ul>
<li>AzureWebJobsScriptRoot<br>代表 Azure functions 專案的執行根目錄，也就是 host.json 的目錄；</li>
<li>AzureFunctionsJobHost{__path__to__setting}<br>設定需要複寫(overwrite) host.json 裡面的變數值，__path__to__settings 可<a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-host-json#override-hostjson-values">參考說明</a>換成需要的變數名稱，例如：AzureFunctionsJobHost__Logging_Console__IsEnabled；</li>
</ul>
<p>設定 Azure functions 的環境變數，可以從兩個來源：</p>
<ul>
<li>固定寫在 Docker image：常放一些通用的資訊</li>
<li>利用 Azure portal 上的應用程式設定：建議放有安全疑慮的資訊</li>
</ul>
<p>兩個來源在 functions 執行時組合在 environment variables，以 node.js 為例，可以使用 <code>process.env.XXXXX</code> 的方式來取得；<br>在測試 docker image 時，建議使用 Http Trigger 的 azure function，因為較能方便測試與除錯。</p>
<h1 id="建立-docker-container-與本機測試"><a href="#建立-docker-container-與本機測試" class="headerlink" title="建立 docker container 與本機測試"></a>建立 docker container 與本機測試</h1><p><code>docker build --tag &lt;docker ID&gt;/my_az_functions_image:latest .</code><br>如果有修改專案，要記得重新建立 image 並送到 regsitry。</p>
<p>本機測試檢查 http trigger 是否被掛起：<br><code>docker run -it --rm -p 8080:80 &lt;docker ID&gt;/my_az_functions_image:latest</code></p>
<p>啟動後，利用 <code>http://localhost:8080/api/&#123;http trigger name&#125;?name=pou</code> 檢查 function 是否被掛起；如果預設使用 template 建立的 http trigger 會看到對應的 response，例如下面的 log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info: Function.HttpGreeting[1]</span><br><span class="line">      Executing &#x27;Functions.HttpGreeting&#x27; (Reason=&#x27;This function was programmatically called via the host APIs.&#x27;, Id=cb489e5e-ef7e-4840-aa08-9bf1bcc32961)</span><br><span class="line">info: Function.HttpGreeting.User[0]</span><br><span class="line">      JavaScript HTTP trigger function processed a request.</span><br><span class="line">info: Function.HttpGreeting[2]</span><br><span class="line">      Executed &#x27;Functions.HttpGreeting&#x27; (Succeeded, Id=cb489e5e-ef7e-4840-aa08-9bf1bcc32961, Duration=115ms)</span><br><span class="line">info: Function.HttpGreeting[1]</span><br><span class="line">      Executing &#x27;Functions.HttpGreeting&#x27; (Reason=&#x27;This function was programmatically called via the host APIs.&#x27;, Id=61e1265a-59c3-4d24-86c8-2c7d55021149)</span><br><span class="line">info: Function.HttpGreeting.User[0]</span><br><span class="line">      JavaScript HTTP trigger function processed a request.</span><br><span class="line">info: Function.HttpGreeting[2]</span><br><span class="line">      Executed &#x27;Functions.HttpGreeting&#x27; (Succeeded, Id=61e1265a-59c3-4d24-86c8-2c7d55021149, Duration=7ms)</span><br></pre></td></tr></table></figure>

<p>使用 timer trigger 要記得啟動 docker 時帶入 AzureWebJobsStorage 的設定值才能正常執行，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在根目錄加入 dev.env</span><br><span class="line">AzureWebJobsStorage=DefaultEndpointsProtocol=https;AccountName=myazfunctions;AccountKey=ONDu3VvJpg;EndpointSuffix=core.windows.net&quot;</span><br><span class="line"></span><br><span class="line">// 執行 docker 時加入 env file </span><br><span class="line">docker run -it --rm -p 8080:80 --env-file ./dev.env &lt;docker ID&gt;/my_az_functions_image:latest</span><br></pre></td></tr></table></figure>

<h1 id="上傳-Docker-Image-到-Docker-Hub"><a href="#上傳-Docker-Image-到-Docker-Hub" class="headerlink" title="上傳 Docker Image 到 Docker Hub"></a>上傳 Docker Image 到 Docker Hub</h1><p><code>docker push &lt;docker ID&gt;/my_az_functions_image:latest </code><br>上傳完畢後，可以從 Docker Hub 看到上傳的內容。</p>
<h1 id="建立-Azure-Function"><a href="#建立-Azure-Function" class="headerlink" title="建立 Azure Function"></a>建立 Azure Function</h1><ul>
<li>選擇 Docker-Container<br><img src="/2022/01/28/DevOps/custom-image-on-azure-functions/1_sZr48yiG9sLcMsHJoeNFcw.png"></li>
<li>建立 Storage account, 選擇 Linux 與 App service Plan(要 premium 喔)<br><img src="/2022/01/28/DevOps/custom-image-on-azure-functions/1_6GJoxBMqhhuNLP15Sa2WtQ.png"><br>也可以<a href="https://docs.microsoft.com/zh-tw/azure/azure-functions/functions-create-function-linux-custom-image?tabs=in-process,bash,azure-cli&pivots=programming-language-javascript#create-supporting-azure-resources-for-your-function">利用 CLI 的方式建立 Azure function 與對應的 resource group</a>。</li>
</ul>
<h1 id="到-Azure-functions-的-portal-把必要環境變數加入"><a href="#到-Azure-functions-的-portal-把必要環境變數加入" class="headerlink" title="到 Azure functions 的 portal 把必要環境變數加入"></a>到 Azure functions 的 portal 把必要環境變數加入</h1><p><img src="/2022/01/28/DevOps/custom-image-on-azure-functions/1_a2vR3iXjYmn0RS0DZ9HaGQ.png"><br>詳細設定可參考 <a href="https://docs.microsoft.com/en-us/azure/app-service/configure-common">Configure apps in the portal — Azure App Service</a> 與 <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-node?tabs=v2#environment-variables">JavaScript developer reference for Azure Functions</a>。</p>
<h1 id="部署到-Azure-functions"><a href="#部署到-Azure-functions" class="headerlink" title="部署到 Azure functions"></a>部署到 Azure functions</h1><p><code>az functionapp create --name &lt;APP_NAME&gt; --storage-account &lt;STORAGE_NAME&gt; --resource-group &lt;RESOURCE_GROUP&gt; --plan myPremiumPlan --deployment-container-image-name &lt;DOCKER_ID&gt;/azurefunctionsimage:v1.0.0</code></p>
<p>其中的 <App_Name>、<RESOURCE_GROUP>、<STORAGE_NAME>、<DOCKER_ID>請已上面步驟建立的值做更換。</p>
<h1 id="設定-Azure-functions-使用的-Storage-connection"><a href="#設定-Azure-functions-使用的-Storage-connection" class="headerlink" title="設定 Azure functions 使用的 Storage connection"></a>設定 Azure functions 使用的 Storage connection</h1><p>設定 Storage connection 可參考下面的指令，或是使用步驟 4 的介紹從 Azure Portal 上進行設定。<br>Storage connection 的值必須設定在 AzureWebJobsStorage。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 取得 Stroage connection</span><br><span class="line">az storage account show-connection-string --resource-group &lt;RESOURCE_GROUP&gt; --name &lt;STORAGE_NAME&gt; --query connectionString --output tsv</span><br><span class="line"></span><br><span class="line">// 設定 Azure function 使用的 Storage connection</span><br><span class="line">az functionapp config appsettings set --name &lt;APP_NAME&gt; --resource-group &lt;RESOURCE_GROUP&gt; --settings AzureWebJobsStorage=&lt;CONNECTION_STRING&gt;</span><br></pre></td></tr></table></figure>

<h1 id="確認-Azure-Function-是否正確被執行"><a href="#確認-Azure-Function-是否正確被執行" class="headerlink" title="確認 Azure Function 是否正確被執行"></a>確認 Azure Function 是否正確被執行</h1><p>在步驟 2 介紹使用 HTTP trigger，所以可透過下面的連結來做測試<br><code>https://&lt;APP_NAME&gt;.azurewebsites.net/api/&#123;http trigger name&#125;?name=pou</code></p>
<p>以上是紀錄把 Azure Function 用 Docker Image 包裝起來的方法。<br>如果大家有遇到其他問題歡迎一起討論。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-node">Quickstart: Create a JavaScript function in Azure using Visual Studio Code</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-function-linux-custom-image?tabs=in-process,bash,azure-cli&pivots=programming-language-javascript">Create a function on Linux using a custom container</a></li>
<li><a href="https://hub.docker.com/_/microsoft-azure-functions-base?tab=description">Azure Functions base Images</a> &amp; <a href="https://github.com/Azure/azure-functions-docker">Github</a></li>
<li><a href="https://www.programmingwithwolfgang.com/deploy-docker-container-azure-functions/">Deploy a Docker Container to Azure Functions using an Azure DevOps YAML Pipeline</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-app-settings#azurewebjobsscriptroo">App settings reference for Azure Functions</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-host-json#override-hostjson-values">Override host.json values</a></li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Azure</tag>
      </tags>
  </entry>
  <entry>
    <title>如何取得 GitLab 另一個 Pipeline 的 artifacts</title>
    <url>/2022/05/28/DevOps/gitlab-integrated-pipelines/</url>
    <content><![CDATA[<p>介紹如何透過 GitLab API 在 Upstream 取得 Downstream 的 artifact。</p>
<span id="more"></span>
<p>大家都熟悉在 repo 裏面建立自己的 GitLab CI&#x2F;CD，一個 repo 每次產生一組 pipeline 裏面帶有多個 jobs，如下圖：</p>
<p><img src="/2022/05/28/DevOps/gitlab-integrated-pipelines/0_N35pBzNuBNRg5K1b.png"></p>
<p>那如果需要在 A repo 的 pipeline 通知 repo B 一起進行編譯，並把 repo B 的 artifact 放進 A repo 的 artifact 時，我們能怎麽做？</p>
<p>option 1: 把 repo B 加入 repo A 的 sub module 一起編譯</p>
<p>option 2: 利用 GitLab 的 multiple-project pipeline 機制觸發另一個 pipeline</p>
<p>本篇將介紹 option 2 的 multiple-project pipeline 機制。</p>
<h1 id="基本介紹-multiple-project-pipeline"><a href="#基本介紹-multiple-project-pipeline" class="headerlink" title="基本介紹 multiple-project pipeline"></a>基本介紹 multiple-project pipeline</h1><p>GitLab CI&#x2F;CD 支援跨 project 的特性，由一個 pipeline 觸發另一個 pipeline。</p>
<p>觸發者被稱爲 upstream，接受被觸發的稱爲 downstream (它可以多個)。</p>
<p>如何觸發另一個 repo 的 pipeline 呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - trigger_repob</span><br><span class="line">  - buildTrigger-Repo-B:</span><br><span class="line"> </span><br><span class="line">stage: trigger_repob</span><br><span class="line">  variables:</span><br><span class="line">    ENVIRONMENT: staging</span><br><span class="line">  trigger: </span><br><span class="line">    project: my_group/repoB</span><br><span class="line">    branc: dev</span><br><span class="line">    strategy: dependBuild-Repo-A:</span><br><span class="line">  stage: build</span><br><span class="line">  script:</span><br><span class="line">    - echo &quot;upstream&quot;</span><br></pre></td></tr></table></figure>
<p>關鍵字：<strong>trigger</strong>，它可指定變數從到 downstream，或是要觸發的 project 與 branch，以及是否要等待 pipeline 執行狀態再接著往下。</p>
<p>trigger 下可以用的 keywords 可以參考 Trigger job configuration keywords。</p>
<p>觸發其他 project 的 pipeline 的畫面如下，可以看到 Downstream 可有多個，而且各自 Downstream 的 pipeline 可同時進行：</p>
<p><img src="/2022/05/28/DevOps/gitlab-integrated-pipelines/0_nKLsfI8gNXjYY0W6.png"></p>
<p>更多詳細的介紹請參考 Multiple-project pipelines。</p>
<p>取得 Downstream 的 artifact</p>
<p>熟悉 Multiple-project pipelines 後，接下來是重點，我怎麽能從 upstream 取得 downstream 裏面 Job 的 artifact 呢？</p>
<p>從 GitLab issues 可以找到很多人許願這樣的功能：<a href="https://gitlab.com/gitlab-org/gitlab/-/issues/285100">Allow job in upstream pipeline to reference artifacts from a downstream pipeline</a>，但目前還沒有被支援，不過這篇裏面有人介紹了 workaround 做法，我們來看看吧。</p>
<p>以下 GitLab API 是我們下手的機會：</p>
<p><a href="https://docs.gitlab.com/ee/api/jobs.html#list-pipeline-trigger-jobs">List pipeline bridges</a>：取得 upstream 下擁有的 downstream pipeline<br><a href="https://docs.gitlab.com/ee/api/jobs.html#list-pipeline-jobs">List pipeline jobs</a>：取得 pipeline 的 jobs<br><a href="https://docs.gitlab.com/ee/api/job_artifacts.html#get-job-artifacts">Get job artifacts</a>：取得 job 的 artifacts</p>
<p>API 的使用流程(記得要申請 GitLab API Token)如下：<br><img src="/2022/05/28/DevOps/gitlab-integrated-pipelines/0_QGpkFooLNK8YGmJU.png"></p>
<p>使用 API 的流程，我不建議寫在 .gitlab-ci.yml，因爲非常難 debug，因此，如果您是熟悉 shell 或 powershell 的人可以直接包裝成執行檔來進行。</p>
<p>以下是我用 powershell 寫的範例(rebuild.ps1: 假設 repoB 有一個 job: build-repo 是我想要的 artifact)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># use Bridge API to get downstream project id</span><br><span class="line">$BRIDGE_API = &quot;$CI_API/$PROJECT_ID/pipelines/$PIPELINE_ID/bridges&quot;</span><br><span class="line">$response = Invoke-RestMethod -URI $BRIDGE_API -HEADERS @&#123;&#x27;PRIVATE-TKEN&#x27; = $TOKEN &#125;</span><br><span class="line">$downstream_project_id = $response.downstream_pipleline.project_id</span><br><span class="line"></span><br><span class="line"># use Job API to get job content by downstream pipeline id</span><br><span class="line">$JOB_API = &quot;$CI_API/$downstream_project_id/pipelines/jobs&quot;</span><br><span class="line">$response = Invoke-RestMethod -URI $JOB_API -HEADERS @&#123;&#x27;PRIVATE-TKEN&#x27; = $TOKEN &#125;</span><br><span class="line"></span><br><span class="line"># find target job to get id and artifact</span><br><span class="line">$job_id = &quot;&quot;</span><br><span class="line">$artifact = &quot;&quot;foreach ($job in $response) &#123;</span><br><span class="line">  if ($job.name -eq &quot;build-repo&quot;) &#123;</span><br><span class="line">     $artifact = $job.artifacts_file</span><br><span class="line">     $job_id = $job.id  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># download artifact</span><br><span class="line">$ARTIFACTS_API = &quot;$CI_API/$downstream_project_id/jobs/$job_id/artifacts&quot;</span><br><span class="line">Invoke-RestMethod -URI $ARTIFACTS_API -HEADERS @&#123;&#x27;PRIVATE-TKEN&#x27; = $TOKEN &#125; -OutFile &quot;./$($artifact.filename)&quot;</span><br></pre></td></tr></table></figure>
<p>最終合并到 .gitlab-ci.yml 的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - deploybuild-sharecode:</span><br><span class="line">  </span><br><span class="line">stage: build</span><br><span class="line">  trigger:</span><br><span class="line">    project: poulin/shopping-radar-sharecode</span><br><span class="line">    branch: master</span><br><span class="line">    strategy: depend</span><br><span class="line">    </span><br><span class="line">deploy-linbot:</span><br><span class="line">  stage: delpoy</span><br><span class="line">  script:</span><br><span class="line">    - echo &quot;start build&quot;</span><br><span class="line">    - powershell &quot;./rebuild.ps1&quot; &quot;$CI_API_V4_URL/projects&quot; $CI_PROJECT_ID $CI_PIPELINE_ID $env:GITLAB_TOKEN</span><br><span class="line">    - cp ./sharecode ./bin</span><br><span class="line">  needs:</span><br><span class="line">    - build-sharecode</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br><span class="line">  tags:</span><br><span class="line">    - windows</span><br><span class="line"></span><br><span class="line">做法確實很 workaround，但很實用。上面的範例是針對 downstream 下的其中一個 job，如果您有多個 job 的 artifacts 要存取也可以修改裏面的程式碼進行使用哦。</span><br></pre></td></tr></table></figure>

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://gitlab.com/gitlab-org/gitlab/-/issues/285100">List pipeline bridges</a></li>
<li><a href="https://docs.gitlab.com/ee/api/job_artifacts.html#get-job-artifacts">Get job artifacts</a></li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
</search>
